%% Master thesis on Adaptive learning of programming.
\documentclass[
    %printed,
    digital,
    color,
    11pt,
    nocover,
    table,  % coloured tables; (to disable: notable)
    nolof,  % hide List of Figures
    nolot,  % hide List of Tables
    microtype,
    %final,
]{fithesis3}
%% Locales.
\usepackage[resetfonts]{cmap}
\usepackage[T1]{fontenc}
\usepackage[
  main=english,
  english, czech
]{babel}
%% Metadata.
\thesissetup{
    date          = \the\year/\the\month/\the\day,
    university    = mu,
    faculty       = fi,
    type          = mgr,
    author        = Tomáš Effenberger,
    gender        = m,
    advisor       = {doc. Mgr. Radek Pelánek, Ph.D},
    title         = {Adaptive System for Learning Programming},
    TeXtitle      = {Adaptive System for Learning Programming},
    keywords      = {adaptive learning, student modeling, learning programming},
}
%% Bibliography.
\usepackage[backend=biber, 		% use biber as backend instead of BiBTeX
	bibstyle=ieee-alphabetic, 	% bibliography style: IEEE with alphabetic citations
	citestyle=alphabetic, 		% citation style
	url=true, 			        % display urls in bibliography
	hyperref=auto,			    % detect hyperref and create links
]{biblatex}
\addbibresource{thesis.bib}
%% Abstract.
\thesislong{abstract}{%
TBA: abstract
}
%% Thanks.
\thesislong{thanks}{%
TBA: thanks, TBA: mention RH and MU projects
}
%% Index.
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% Compact lists.
\usepackage{paralist}
\usepackage{enumitem}
\setitemize{noitemsep,topsep=3pt,parsep=3pt,partopsep=3pt}
%% Mathematics
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
%% URLs.
\usepackage{url}
\usepackage{hyperref}
\begin{document}

\chapter{Introduction}
\label{chap:introduction}

TBA: introduction

\chapter{Learning Programming}
\label{chap:learning-programming}

This chapter describes the current state of the art of teaching programming, both from the view of successful learning systems and from the view of a research on learning programming.

\section{Existing Systems for Learning Programming}
\label{sec:existing-systems}

There are many systems for learning programming.
These systems can be grouped by several criteria:

\begin{itemize}
\item computer systems or physical toys,
\item web application, mobile application, or computer program,
\item target group, e.g. children in a class,
\item assumed prerequisites,
\item covered concepts, % e.g. loops, conditions, functions, recursion, particular language features
\item free or paid.
\end{itemize}

In this section, we present the most notable of them with brief descriptions.
Section \ref{sec:strategies-for-easier-learning} then attempts to extrapolate useful strategies for teaching programming.


\subsection{LightBot}
\label{sec:lightbot}
LightBot%
\footnote{Available at \url{http://lightbot.com/}.}
is a web page with a fixed sequence of tasks for learning programming
using block-based programming language.
Students create simple programs to control a robot living in a grid world.
The robot can perform two types of movement (walking and jumping),
which is important for diversity of easy tasks.
The system covers sequences of commands, procedures, and simple loops via tail-recursion.

// TBA: screenshot


\subsection{Robozzle}
\label{sec:robozzle}
With a robot on a grid and block-based programming, Robozzle%
\footnote{Available at \url{http://www.robozzle.com/}.}
is similar to LightBot;
however, it adds a new feature: colors on the grid.
Colors can be used in conditional commands.
Robozzle shows that a carefully chosen set of a few orthogonal commands is enough for creating hundreds of diverse tasks,
  including difficult tasks with sophisticated recursion.
Robozzle also allows users to create their own tasks,
  which can be tried and rated by other learners.

// TBA: screenshot


\subsection{BlocklyGames}
\label{sec:blockly-games}
Blockly is a popular block-based programming interface.
In contrast to the blocks in LightBot and Robozzle,
Blockly blocks can be assembled in nested control structures.

The main purpose of BlocklyGames%
\footnote{Available at \url{https://blockly-games.appspot.com/}.}
is to provide a demo of possible Blockly usages.
The webpage consists of several simple games, ordered in increasing difficulty.
For example, in the first level, students learn how to compose blocks together as a puzzle,
and in the second level they learn loops and conditions by solving tasks in a maze.
Final level serves as a transition from block-based programming to textual JavaScript programming.
Each game consists of 5-10 tasks, again with fixed ordered by increasing difficulty, with no personalization.
The fixed order enables to use the program from the previous task,
thus gradually build more and more complex programs,
resulting in, for example, sophisticated images in turtle graphics.
Another notable feature of the system are non-ignorable instructions,
which requires to take a described action before they disappear
\cite{blockly-10-things}.

// TBA: screenshot


\subsection{Human Resource Machine}
\label{sec:human-resource-machine}
Human Resource Machine%
\footnote{Available at \url{http://tomorrowcorporation.com/humanresourcemachine}.}
is an example of a paid offline computer game for learning programming using block-based programming interface.
Although it is presented as a game,
the player spends nearly all the time solving tasks similar to those in the previously mentioned learning systems.
The sequence of tasks is non-personalized and nearly linear,
with only a few short side branches.
Main difference from the other systems is a slightly different domain:
it uses more low-level programming commands, such as
input, output, move-from, move-to, add, or jump.
% input, output, move-to, move-from, add, sub, jump, jump-nonzero, jump-negative.
The game comes with a debugger, giving a possibility to step through the program.
All elements are explained when they first appear and programming blocks can be explained again simply by dragging the block onto a field with a question mark.

// TBA: screenshot


\subsection{Ozobot}
\label{sec:ozobot}
Ozobot%
\footnote{Information available at \url{http://ozobot.com/}, simulator at \url{http://games.ozoblockly.com}.}
is a small physical robot
programmable by either a Blockly-based interface,
  or even without a computer
  by drawing lines on a paper and reading them with a color sensor on the robot.
As it does not require ability to read and write,
  Ozobot is suitable for even very young children.

// TBA: screenshot


\subsection{Problem Solving Tutor}
\label{sec:problem-solving-tutor}
Problem Solving Tutor%
\footnote{Available at \url{tutor.fi.muni.cz}.}
includes a few problem sets for practicing programming,
such as Interactive Python, Robot Karel or Robotanist.
Robotanist is a variation on the Robozzle,
offering both easy introductory tasks requiring no previous exposure to programming,
as well as extremely difficult tasks on sophisticated use of recursion.
After each solved task, Problem Solving Tutor shows a recommendation for two next tasks,
with predicted solving time.
According to the authors, showing predicted time to the user serves as a motivational element
-- it poses a suitable challenge to ``overcome oneself''
\cite{pelanek-student-modeling-times}.

// TBA: screenshot


\subsection{Project Euler}
\label{sec:project-euler}
The core of Project Euler%
\footnote{Available at \url{projecteuler.net}.}
is a list of several hundreds of programming problems with one correct answer.
The problems can be solved in any language
and then checked whether the computed answer is correct.
The project is not meant to teach elementary programming,
but rather to hone one’s programming skills;
more complicated tasks require even some knowledge of algorithms and data structures.
The system provides several means of motivation:
levels (based purely on number of solved tasks), badges
(e.g. for solving 10 consecutive problems, 50 prime numbered problems, etc.),
comparison with user’s friends,
statistics page with several leaderboard (e.g. by country),
and a special score based on the performance on the most recently published problems.

// TBA: screenshot


\subsection{HackerRank}
\label{sec:hacker-rank}

Online programming contests,
in which people attempt to solve as many problems as possible
in limited time frame of a few hours,
became popular in the last years.
In addition to organizing such contests regularly,
HackerRank%
\footnote{Available at \url{https://www.hackerrank.com/}.}
also provides many training programming tasks for various topics,
from introductory programming to machine learning.
% Solutions are evaluated on a server against a prepared set of test cases with time limits.
In addition to the classic motivation in the form of points, badges and leaderboards, students are motivated to practice to perform well in the competitions,
where they can win some prices and sometimes even job offers.
HackerRank also helps student to decide on a problem to solve by showing its difficulty according to the author of the task (on a 3-star scale),
as well as success rate among the past submissions.
Furthermore, after solving a task,
a specific recommendation the next task to solve is shown.

// TBA: screenshot


\section{Strategies for Easier Learning}
\label{sec:strategies-for-easier-learning}

Learning programming is difficult,
  because it requires
  to adopt algorithmic thinking,
  understand program execution,
  and remember a formal syntax of a programming language,
  all at the same time.
To make learning easier,
  the systems presented in the previous section use diverse strategies,
  including avoiding syntax errors,
  providing visual output
  and showing helpful hints.
Various other strategies were tried in the past;
article \emph{Lowering barriers for Novice Programmers}
  \cite{lowering-barriers}
  provides a detailed overview.


\subsection{Avoiding Syntax Errors}
\label{sec:avoiding-syntax-errors}

A common strategy in the current systems for learning programming is to avoid syntax errors
  by replacing textual programming with a drag-and-drop block-based programming.
There are two basic types of block-based interfaces:
  either there is a square grid defining the program shape
  (often one row per function),
  or the blocks can be nested and assembled freely with no limitation on maximum program length
  (often one vertical stack per function).
Fixed grid is simpler for understanding and manipulation,
  but it does not allow for direct nesting,
  which is a fundamental feature of computer programs.
This restriction is usually overcome by
  combining condition and a command into a single block,
  using recursion instead of loops,
  and replacing nested sequences of commands by a new function.

// TBA: comparision figure; e.g. Robotanist - fixed grid, Blockly games - nested blocks


\subsection{Potential Drawback of Block-based Interfaces}
\label{sec:potential-drawback-of-block-based-interfaces}
A drawback of using a block-based programming
  is the students' need to learn a proper textual languages afterwards anyway
  to be able to implement more complex programs.
Several controlled experiments were performed to test the hypothesis
  that it is still beneficial to start an introductory programming course
  with a block-based programming,
  even when the students will be writing code later in the course.
While the results of these experiments suggest that block-based interfaces
  might be the better choice for the start,
  they do not provide strong convincing evidence for that,
  because the programming interfaces used in most of the experiments differ in more aspects
  than in just in using blocks instead of text
  \cite{comparing-textual-and-block-interfaces}.

\subsection{Transition Strategy}
\label{sec:transition-strategy}
Weintrop and Wilensky suggest that the block representation of the code
  should match the underlying programming language
  to which the student is expected to move in the next phase
  \cite{challenges-of-blocks-based-environments}.
However, the readability of the blocks for learners
  and the resemblance to a programming language
  are sometimes conflicting requirements.
Instead of making compromises,
  BlocklyGames progressively change the available set of blocks in each level,
  making them more similar to JavaScript.
In the last level,
  the text on blocks matches the generated JavaScript completely
  \cite{blockly-10-things}.


\subsection{Visual Output}
\label{sec:visual-output}

Good learning systems can help students to track a program execution
  by providing a vivid visual representation of the effects of the program
  together with the current state.
This can be achieved naturally for turtle graphics,
  where the whole state is just a position and orientation of the turtle.
Similarly, in simple games, a grid world with a robot
  contains the full information about the current state.
For the simplicity of their visual output,
  turtle graphics and grid world games have become prevalent task types
  in the current systems for learning programming.

// TBA: figures to illustrate the point; figures to show variants of graphical output


\subsection{Instructions and Hints}
\label{sec:instructions-and-hints}

Most systems for learning elementary programming includes instructions
  to explain new concepts, such as loops and conditions.
However, Neil Fraser explains that students ignore instructions,
  no matter how prominent they are \cite{blockly-10-things}.
His solution in BlocklyGames are non-ignorable, actionable instructions,
  which cannot be closed manually by the student;
  they will only disappear once the student perform the action described in the instruction.

BlocklyGames also include additional hints,
  which only appear after a certain time of unsuccessful solving.
Theoretically, it is possible to generate a hint in any state,
  using data of students which have successfully solved the task before
  \cite{generating-hints},
  but these automatic approaches have not been employed in practice;
  instead, a few manually prepared instructions are usually used.

// TBA: figure: LightBot provides clear and simple interactive instructions.

\section{Motivation}
\label{sec:motivation}

In addition to employing the teaching strategies mentioned in section \ref{sec:strategies-for-easier-learning},
  it is equally important to create an engaging environment supporting students’ motivation. Common strategies for increasing motivation are:

\begin{itemize}
\item explaining the usefulness of the programming skill,
\item appealing game world, which is nice to look at and fun play with,
\item gamification elements, such as points and badges,
\item social elements, such as possibility to share programs or achievements,
\item creativity and self-expression (possibility to create own programs),
\item appropriate challenge.
%TODO: consider also: feel of power/control; progress/learning
%TODO: connect those to fulfilling common needs such as being recognized etc.
\end{itemize}


\subsection{Game World}
\label{sec:motivation.game-world}
Ideally, game world should appeal students --
even without tasks to solve,
  it should be an interesting toy to play with.
In such environments, it is possible to assign open-ended tasks,
  or even let the students create whatever they want,
  which works well especially for creative students seeking for self-expression.

// TBA: figures, providing diverse examples of interesting worlds, including several grid worlds and turtle graphics


\subsection{Tasks}
\label{sec:motivation.tasks}
For many students, giving them specific small problems works better
  than large, loosely defined and open-ended tasks.
By solving small problems quickly,
  they get a feeling of progress and learning.
Another advantage of close tasks
  is a more straightforward implementation of gamification features and adaptive behavior.

Small closed tasks result in short programs,
  but their behavior should be still interesting for the students to be satisfied.
To achieve complex behavior,
  a system can either provide students with macro-commands (e.g. to draw a circle)
  or with a skeleton of complex code, with a few gaps to fill in by students.
However, it is important for the students to feel ownership over the code,
  which is especially a concern with a code skeleton.
Solution suggested by Neil Fraser (and implemented in Blockly Games)
  is to make a series of tasks in which the students
  build on their program from the previous task
  \cite{blockly-10-things}.

// TBA: again some examples in a form of figures + descriptions

%TODO: other important aspects: variability


\subsection{Challenge}
\label{sec:motivation.challenge}
For a great learning experience,
  difficulty of the task must match the skill of the student.
If the task it too easy,
  student is not challenged and gets bored.
If the task is too difficult,
  student gets frustrated and desperate.
On the other hand, if the task has appropriate difficulty,
  student is likely to be challenged and focused.
The complete immersion into the task the student is solving at the moment is called
  a state of flow \cite{flow}.
Achieving the state of flow maximizes the learning outcome \cite{adaptive-practice},
  and even increases the long-term level of happiness. % TODO: find a source of this claim
Next chapter describes techniques for estimating student’s skill
  and show how use that estimate for task recommendation.

// TBA: flow diagram


\chapter{Adaptive Learning}
\label{chap:adaptive-learning}

TBA: intro to adaptive learning


\section{Student Modeling}
\label{sec:student-modeling}

TBA


\section{Task Recommendation}
\label{sec:task-recommendation}

TBA


\section{Metrics and Evaluation}
\label{sec:metrics-and-evaluation}

TBA


\section{Iterative Improvement}
\label{sec:iterative-improvement}

TBA


\chapter{Design of Robomission}
\label{chap:design-of-robomission}

TBA: intro about Robomission

\section{Game World}
\label{sec:robomission.game-world}

TBA

\section{Tasks}
\label{sec:robomission.tasks}

TBA


\section{Learning System}
\label{sec:robomission.system}

TBA


\chapter{Implementation of Robomission}
\label{chap:implementation-of-robomission}

TBA

\section{System Architecture}

TBA

\section{Frontend}

TBA


\section{Backend}

TBA

\section{Clean Core}

TBA


\section{SpaceWorld Grammar}

TBA


\section{RoboCode Grammar}

TBA


\chapter{Analysis of Collected Data}
\label{chap:analysis}

TBA

\section{Data Description}

TBA, including descriptive statistic and visualization


\section{Explorative Analysis}

TBA


\section{Hypothesis Testing}

TBA


\section{Results}

TBA



\chapter{Template Chapter}
\label{chap:template}

Citation example: \cite{adaptive-practice}.


\chapter{Conclusion}
\label{chap:conclusion}

\section{Summary}
\label{sec:conclusion.summary}

TBA

\section{Future work}
\label{sec:conclusion.future-work}

TBA


% ===== APPENDIX AND BIBLIOGRAPHY =====

\printbibliography[heading=bibintoc]

\appendix

\chapter{Glossary}
\label{chap:glossary}

\begin{description}
    \item[Flow] TBA: add definition of flow.
\end{description}

\chapter{Data attachment}
\label{chap:data}

TBA: data attachment

\end{document}
