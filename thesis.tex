%% Master thesis on Adaptive learing of programming.
\documentclass[
    %printed,
    digital,
    color,
    11pt,
    nocover,
    table,  % coloured tables; (to disable: notable)
    nolof,  % hide List of Figures
    nolot,  % hide List of Tables
    microtype,
    %final,
]{fithesis3}
%% Locales.
\usepackage[resetfonts]{cmap}
\usepackage[T1]{fontenc}
\usepackage[
  main=english,
  english, czech
]{babel}
%% Metadata.
\thesissetup{
    date          = \the\year/\the\month/\the\day,
    university    = mu,
    faculty       = fi,
    type          = mgr,
    author        = Tomáš Effenberger,
    gender        = m,
    advisor       = {doc. Mgr. Radek Pelánek, Ph.D},
    title         = {Adaptive System for Learning Programming},
    TeXtitle      = {Adaptive System for Learning Programming},
    keywords      = {adaptive learning, student modeling, learning programming},
}
%% Bibliography.
\usepackage[backend=biber, 		% use biber as backend instead of BiBTeX
	bibstyle=ieee-alphabetic, 	% bibliography style: IEEE with alphabetic citations
	citestyle=alphabetic, 		% citation style
	url=true, 			        % display urls in bibliography
	hyperref=auto,			    % detect hyperref and create links
]{biblatex}
\addbibresource{thesis.bib}
%% Abstract.
\thesislong{abstract}{%
TBA: abstract
}
%% Thanks.
\thesislong{thanks}{%
TBA: thanks, TBA: mention RH and MU projects
}
%% Index.
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% Compact lists.
\usepackage{paralist}
\usepackage{enumitem}
\setitemize{noitemsep,topsep=3pt,parsep=3pt,partopsep=3pt}
%% Mathematics
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
%% URLs.
\usepackage{url}
\usepackage{hyperref}
\begin{document}

\chapter{Introduction}
\label{chap:introduction}

TBA: introduction

\chapter{Learning Programming}
\label{chap:learning-programming}

This chapter describes the current state of the art of teaching programming, both from the view of successful learning systems and from the view of a research on learning programming.

\section{Existing Systems for Learning Programming}
\label{sec:existing-systems}

There are many systems for learning programming.
These systems can be grouped by several criteria:

\begin{itemize}
\item computer systems, or physical toys
\item device: online web pages, mobile apps, offline computer programs
\item target group, e.g. children in a class, children at home, …
\item assumed prerequisites, e.g. reading, writing, computer skills, or even elementary programming
\item covered concepts, e.g. loops, conditions, functions, recursion, particular language features
free or paid
\end{itemize}

In this section, we present the most notable of them with brief descriptions. Next section attempt to extrapolate useful strategies for teaching programming.


\subsection{LightBot}
\label{sec:lightbot}
LightBot%
\footnote{Available at \url{http://lightbot.com/}.}
is a web page with a sequence of tasks for learning programming using block-based programming language.
Students write simple programs to control a robot living in a grid world.
Two types of movement (walking and jumping) enables to create variety of easy tasks.
The system provides clear and simple interactive instructions.
The following concepts are covered: commands, procedures and simple loops via tail-recursion.

// TBA: screenshot


\subsection{Robozzle}
\label{sec:robozzle}
With a robot on a grid  and block-based programming, Robozzle%
\footnote{Available at \url{http://www.robozzle.com/}.}
is similar to LightBot.
However, by adding colors to the grid, which can be used for conditioning and enables difficult tasks with recursion.
Robozzle shows that a carefully chosen set of a few orthogonal commands is enough for creating hundreds of diverse tasks.
Robozzle allows users to create their own tasks.
These tasks can be tried and rated by other learners.

// TBA: screenshot


\subsection{BlocklyGames}
\label{sec:blockly-games}
Blockly is a popular block-based programming interface.
In contrast to the block-based interfaces in LightBot and Robozzle,
Blockly doesn’t constrain the “shape” of the program
(program can be arbitrary long and can have arbitrary many functions).
The main purpose of BlocklyGames%
\footnote{Available at \url{https://blockly-games.appspot.com/}.}
is to provide a demo of Blockly usage.
The webpage consists of several games, ordered in increasing difficulty.
For example, in the first level, students learn how to compose blocks together as a puzzle;
in the second level they learn loops and conditions by solving tasks in a maze;
next they practice compound conditions, etc.
Final level serves as a transition from block-based programming to textual JavaScript programming.
Each game consists of 5-10 tasks, again with fixed ordered by increasing difficulty, with no personalization.
The fixed order enables use of the program from the previous task and thus gradually building more and more complex programs,
resulting in e.g. a fairly sophisticated images in turtle graphics.
Another notable feature of the system are non-ignorable instructions,
which requires to take a described action before they disappear
\cite{blockly-10-things}.

// TBA: screenshot


\subsection{Human Resource Machine}
\label{sec:human-resource-machine}
Human Resource Machine%
\footnote{Available at \url{http://tomorrowcorporation.com/humanresourcemachine}.}
is an example of a paid offline computer game for learning programming using block-based programming interface.
Though being presented as a game,
the player spends nearly all the time solving tasks similar to those as in the previously mentioned learning systems.
The sequence of tasks is non-personalized and nearly linear,
with only a few short side branches.
Main difference from the other systems is a slightly different domain:
it uses more low-level programing commands, such as
input, output, move-to, move-from, add, sub, jump, jump-nonzero, jump-negative.
The game comes with a debugger, giving a possibility to step through the program.
All elements are explained when they first appear and programming blocks can be explained again simply by dragging the block onto a field with a questionmark.

// TBA: screenshot


\subsection{Ozobot}
\label{sec:ozobot}
Ozobot%
\footnote{Information available at \url{http://ozobot.com/}, simulator at \url{http://games.ozoblockly.com}.}
is a small physical robot,
programmable by either a Blockly-based interface or by drawing lines on a paper.
Therefore, it can be used completely without a computer and does not require ability to read and write,
thus being suitable for very young children.

// TBA: screenshot


\subsection{Problem Solving Tutor}
\label{sec:problem-solving-tutor}
Problem Solving Tutor%
\footnote{Available at \url{tutor.fi.muni.cz}.}
includes a few problem sets for practicing programming,
such as Interactive Python, Robot Karel or Robotanist.
Robotanist is a variation on the Robozzle,
offering both easy introductory tasks requiring no previous exposure to programming,
and extremely difficult tasks on sophisticated use of recursion.
After each solved task, Problem Solving Tutor shows a recommendation of two tasks,
one easier and one more difficult,
with a predicted solving time.
According to authors, showing predicted problem solving time to the user serves as a motivational element
– it poses a suitable challenge to ``overcome oneself''
\cite{pelanek-student-modeling-times}.

// TBA: screenshot


\subsection{Project Euler}
\label{sec:project-euler}
The core of Project Euler%
\footnote{Available at \url{projecteuler.net}.}
is a list of several hundreds of programming problems with one correct answer (usually number).
The problems can be solved in any language
and then checked whether the computed answer is correct by the provided answer checker.
The project is not meant to teach elementary programming,
but rather to hone one’s programming skills;
more complicated tasks require even some knowledge of algorithms and data structures.
The system provides several means for motivation:
levels (based purely on number of solved tasks), badges
(e.g. for solving 10 consecutive problems, 50 prime numbered problems, etc.),
comparison with user’s friends,
statistics page with several leaderboard (e.g. by country),
and a special score for solving the most recently published problems.

// TBA: screenshot


\subsection{HackerRank}
\label{sec:hacker-rank}

Online programming contests,
in which people attempt to solve as many problems as possible
in limited time frame of a few hours,
become popular in the last years.
In addition to organizing such contests,
HackerRank%
\footnote{Available at \url{https://www.hackerrank.com/}.}
also provides many training programming tasks for various topics,
from introductory programming to machine learning.
Solutions are evaluated on a server against a prepared set of test cases with time limits.
In addition to the classic motivation in the form of points, badges and leaderboards, students are motivated to practice to perform well in the competitions,
where they can win some prices and sometimes even price offers.
HackerRank also helps student to decide on a problem to solve by showing a difficulty according to the author of the task (on a 3-star scale),
as well as success rate among the past submissions.
Furthermore, after solving a task,
a specific recommendation for one task to solve next is shown.

// TBA: screenshot


\section{Strategies for Easier Learning}
\label{sec:strategies-for-easier-learning}

Learning programming is difficult,
  because it at the same time requires
  to adopt algorithmic thinking,
  understand program execution
  and remember a formal syntax of a programming language.
To make learning easier,
  the systems presented in the previous section use diverse strategies,
  including avoiding syntax errors,
  providing visual output
  and showing helpful hints.
Various other strategies were tried in the past;
paper \emph{Lowering barriers for Novice Programmers}
  \cite{lowering-barriers}
  provides a detailed overview.


\subsection{Avoiding Syntax Errors}
\label{sec:avoiding-syntax-errors}

Common strategy in the current systems for learning programming is to avoid syntax errors
  by replacing textual programming with a drag-and-drop block-based programming.
There are two basic types of block-based interfaces:
  either there is a square grid defining the program shape
  (often one row per function),
  or the blocks can be nested and assembled freely with no limitation on maximum program length
  (often one vertical stack per function).
Fixed grid is simpler for understanding and manipulation,
  but it doesn’t allow for direct nesting,
  which is a fundamental feature of computer programs.
This restriction is usually overcome by
  combining condition and a command into a single block,
  using recursion instead of loops,
  and replacing nested sequences of commands by a new function.

// TBA: comparision figure; e.g. Robotanist - fixed grid, Blockly games - nested blocks


\subsection{Potential Drawback of Block-based Interfaces}
\label{sec:potential-drawback-of-block-based-interfaces}
A drawback of using a block-based programming
  is that students need to learn a proper textual languages afterwards anyway
  to be able to implement more complex programs.
Several controlled experiments were performed to test a hypothesis
  that it is still beneficial to start an introductory programming course
  with a block-based programming,
  even when the students will be writing code later in the course.
While the results of these experiment suggest that block-based interfaces
  are the better choice for the start,
  they do not provide strong convincing evidence for that,
  because the programming interfaces used in most of the experiments differ in more aspects
  than in just in using blocks instead of text
  \cite{comparing-textual-and-block-interfaces}.

\subsection{Transition Strategy}
\label{sec:transition-strategy}
Weintrop a Wilensky suggest that for an easy transition
  it is helpful if the block representation of the code
  matches the underlying programming language
  to which the student is expect to move in the next learning phase
  \cite{challenges-of-blocks-based-environments}.
However, the readability of the blocks for learners
  and the resemblance to a programming language
  are sometimes conflicting requirements.
Instead of making compromises,
  BlocklyGames progressively change the available set of blocks in each level,
  making them more similar to JavaScript.
In the last level,
  the text on blocks matches the generated JavaScript completely
  \cite{blockly-10-things}.


\subsection{Visual Output}
\label{sec:visual-output}

Good learning systems can help students to track a program execution
  by providing a vivid visual representation of the effects of the program
  together with the current state.
This can be achieved naturally for turtle graphics,
  where the whole state is just a position and orientation of the turtle.
Similarly, in simple games, a grid world with a robot
  contains the full information about the current state.
For the simplicity of their visual output,
  turtle graphics and grid world games have become prevalent task types
  in the current systems for learning programming.

// TBA: figures to illustrate the point; figures to show variants of graphical output


\subsection{Instructions and Hints}
\label{sec:instructions-and-hints}

In \emph{Ten Things We’ve Learned from Blockly} \cite{blockly-10-things}
  Neil Frase explains that students ignore instructions,
  no matter how prominent they are.
His solution in BlocklyGames are non-ignorable, actionable instructions,
  which can’t be closed manually by the student;
  they will only disappear once the student perform the action described in the instruction.

BlocklyGames also include additional hints,
  which only appears after a certain time of unsuccessful solving.
Theoretically, it is possible to generate a hint in any state,
  using data of students which have successfully solved the task before
  \cite{generating-hints},
  but these automatic approaches have not been employed in practice;
  instead, a few manually prepared instructions are usually used.


\section{Motivation}
\label{sec:motivation}

In addition to employing the teaching strategies mentioned in the previous section,
  it is equally important to create an engaging environment supporting students’ motivation. Common strategies for increasing motivation are:

\begin{itemize}
\item explaining the usefulness of the programming skill,
\item appealing game world, which is nice to look at and fun play with,
\item gamification elements, such as points and badges,
\item social elements, such as possibility to share programs or achievements,
\item creativity and self-expression (possibility to create own programs),
\item appropriate challenge.
%TODO: consider also: feel of power/control; progress/learning
%TODO: connect those to fulfilling common needs such as being recognized etc.
\end{itemize}


\subsection{Game World}
\label{sec:motivation.game-world}
Ideally, students should be appealed to the game world just by looking at it.
Even without tasks to solve,
  it should be an interesting toy to play with.
In such environments, it is possible to assign open-ended tasks,
  or even let the students create whatever they want,
  which works well especially for creative students seeking for self-expression.

// TBA: figures, providing diverse examples of interesting worlds, including several grid worlds and turtle graphics


\subsection{Tasks}
\label{sec:motivation.tasks}
For many students, giving them specific small problems works better
  than large loosely defined and open-ended tasks.
By solving small problems quickly,
  they get a feeling of progress and learning.
Another advantage of close tasks
  is a more straightforward implementation of gamification features and adaptive behavior.

Small closed tasks result in short programs,
  but their behavior should be still interesting for the students to be satisfied.
To achieve complex behavior,
  a system can either provide students with macro-commands (e.g. to draw a circle)
  or with a skeleton of complex code, with a few gaps to fill in by students.
It is important for the students to feel ownership over the code,
  which is especially a concern with a code skeleton.
Solution suggested by Neil Fraser (and implemented in Blockly Games)
  is to make a series of tasks in which the students
  build on their program from the previous task
  \cite{blockly-10-things}.

// TBA: again some examples in a form of figures + descriptions

%TODO: other important aspects: variability


\subsection{Challenge}
\label{sec:motivation.challenge}
For a great learning experience,
  difficulty of the task must match the skill of the student.
If the task it too easy,
  student is not challenged and gets bored.
If the task is too difficult,
  student gets frustrated and desperate.
If the task has appropriate difficulty,
  student is likely to be challenged and focused.
The complete immersion into the task the student is solving right now is called
  a state of flow \cite{flow}.
Achieving the state of flow maximizes the learning outcome \cite{adaptive-practice},
  and even increases the long-term level of happiness. % TODO: find a source of this claim
Next chapter describes techniques for estimating student’s skill
  and show how use that estimate for task task recommendation.

// TBA: flow diagram


\chapter{Adaptive Learning}
\label{chap:adaptive-learning}

TBA: intro to adaptive learning


\section{Student Modeling}
\label{sec:student-modeling}

TBA


\section{Task Recommendation}
\label{sec:task-recommendation}

TBA


\section{Metrics and Evaluation}
\label{sec:metrics-and-evaluation}

TBA


\section{Iterative Improvement}
\label{sec:iterative-improvement}

TBA


\chapter{Design of Robomission}
\label{chap:design-of-robomission}

TBA: intro about Robomission

\section{Game World}
\label{sec:robomission.game-world}

TBA

\section{Tasks}
\label{sec:robomission.tasks}

TBA


\section{Learning System}
\label{sec:robomission.system}

TBA


\chapter{Implementation of Robomission}
\label{chap:implementation-of-robomission}

TBA

\section{System Architecture}

TBA

\section{Frontend}

TBA


\section{Backend}

TBA

\section{Clean Core}

TBA


\section{SpaceWorld Grammar}

TBA


\section{RoboCode Grammar}

TBA


\chapter{Analysis of Collected Data}
\label{chap:analysis}

TBA

\section{Data Description}

TBA, including descriptive statistic and visualization


\section{Explorative Analysis}

TBA


\section{Hypothesis Testing}

TBA


\section{Results}

TBA



\chapter{Template Chapter}
\label{chap:template}

Citation example: \cite{adaptive-practice}.


\chapter{Conclusion}
\label{chap:conclusion}

\section{Summary}
\label{sec:conclusion.summary}

TBA

\section{Future work}
\label{sec:conclusion.future-work}

TBA


% ===== APPENDIX AND BIBLIOGRAPHY =====

\printbibliography[heading=bibintoc]

\appendix

\chapter{Glossary}
\label{chap:glossary}

\begin{description}
    \item[Flow] TBA: add definition of flow.
\end{description}

\chapter{Data attachment}
\label{chap:data}

TBA: data attachment

\end{document}
